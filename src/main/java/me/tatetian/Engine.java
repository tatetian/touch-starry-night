package me.tatetian;

import geomerative.RFont;
import geomerative.RG;
import geomerative.RGroup;
import geomerative.RShape;

import java.awt.Frame;
import java.util.ArrayList;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import ddf.minim.AudioPlayer;
import ddf.minim.Minim;

import me.tatetian.common.Drawable;
import me.tatetian.effects.Animation;
import me.tatetian.scene.MainScene;
import me.tatetian.scene.NebulaScene;
import me.tatetian.scene.Scene;

import processing.core.PApplet;
import processing.core.PFont;

public class Engine extends PApplet {	
	public final float FOV  = PI / 3;
	public final int WIN_W  = 1440;	// width of window
	public final int WIN_H  = 900;	// height of window
	public final int WIN_D  = (int) (- WIN_H / 2 / tan(FOV / 2));	// standard depth of window
	public static final String BASE_PATH  = "data/";
	public final int FRAME_RATE  	= 25;
	
	private Controller controller;
	
	private LinkedList<Animation> animations;
	private List<Animation> newlyAdded;
	
	private Scene currentScene;
	private MainScene mainScene;
	
	private Guide guide;
	
	private char pressKey = 0;
	
	public static void main(String[] args) {
		PApplet.main("me.tatetian.Engine",
    		// the following parameters are not working. But why?
    		new String[] { "--full-screen", "--hide-stop", 
    									 "--bgcolor=#000000", "--display=1", 
    									 "--location=0,0" } );
	}
	
	// force the window to be full screen
	@Override
	public boolean sketchFullScreen() {
		return true;
	}
	
	@Override
	public void setup() {	
		RG.init(this);
		Drawable.setEngine(this);
		Animation.setEngine(this);
		
		// init processing
		size(WIN_W, WIN_H, P3D);
		// frame is null on Windows
		if(frame != null)
			frame.setResizable(false);
		
		background(0);
//		smooth(4);
		imageMode(CENTER);
	  frameRate(FRAME_RATE);
	  
	  perspective(FOV, (float)WIN_W/WIN_H, 1, WIN_D *10); 
	  camera(WIN_W/2, WIN_H/2, 1, WIN_W/2, WIN_H/2, 0, 0, 1, 0); 
	  
	  background(0);
	  
		// init variables
		controller 		= new Controller(this);

		animations 		= new LinkedList<Animation>();
		newlyAdded		= new ArrayList<Animation>();

		// init scenes
		mainScene 		= new MainScene();
		switchScene(mainScene);
//		switchScene(NebulaScene.get(NebulaScene.Name.HIP_10064) );
//		switchScene(NebulaScene.get(NebulaScene.Name.LOU1) );
		//		currentScene 	= new TextScene();		
//		switchScene(NebulaScene.get(NebulaScene.Name.M51) );
		TouchEventHandler.start(this);
		guide = Guide.start(this);
		
		// play background music
		Minim minim = new Minim(this);
		AudioPlayer player = minim.loadFile(BASE_PATH + "sound/background.mp3");
		player.play();
		player.loop();
	}
	
	@Override
	public void draw() {
		perspective(FOV, (float)WIN_W/WIN_H, 1, WIN_D *10); 
	  camera(WIN_W/2, WIN_H/2, 1, WIN_W/2, WIN_H/2, 0, 0, 1, 0); 

		background(0);
		lights();
		currentScene.draw();
		guide.draw();
		doAnimations();
		
		// handle key press event generated by arduino in another thread
		if(pressKey > 0) {
			controller.press(pressKey);
			pressKey = 0;
		}
	}
	
	@Override
	public void mouseClicked() {
		guide.click(mouseX, mouseY);
		controller.click(mouseX, mouseY);
	}

	@Override
	public void mouseMoved() {
		guide.moved();
	}
	
	@Override
	public void keyPressed() {
		controller.press(key);
	}

	public Scene getCurrentScene() {
		return currentScene;
	}
	
	public Scene getMainScene() {
		return mainScene ;
	}
	
	public Controller getController() {
		return controller;
	}
	
	public void queueKeyEvent(char key) {
		if(pressKey == 0)
			pressKey = key;
	}
	
	public void switchScene(Scene scene) {
		Scene fromScene = currentScene;
		currentScene = scene;	
		
		if(fromScene != null)
			fromScene.hide();
		animations.clear();
		
		currentScene.show();
		currentScene.transit(fromScene);
	}
	
	public void addAnimation(Animation a) {
		newlyAdded.add(a);
		a.start();
	}
	
	public void saveNewAnimations() {
		if(!newlyAdded.isEmpty()) {
			animations.addAll(newlyAdded);
			newlyAdded.clear();
		}
	}
	
	public LinkedList<Animation> getAnimations() {
		return animations;
	}
	
	public void doAnimations() {
		saveNewAnimations();
		
		Iterator<Animation> iter = animations.iterator() ;
		while(iter.hasNext()) {
			Animation a = iter.next();
			a.step();
			if(a.progress() == 1) {
				iter.remove();
				a.end();
			}
		}
	}
	
	public static interface Interactive {
		public void click(int mouseX, int mouseY); 
		public void press(char key);
	}
	
	public static class Controller implements Interactive {
		private Engine engine;
		
		public Controller(Engine engine) {
			this.engine = engine;
		}
		
		public void click(int mouseX, int mouseY) {
			engine.currentScene.click(mouseX, mouseY);
		}
		
		public void press(char key) {
			if(key > 0) {
				// CHE2 == CHE3
				if(key == '5') key = '2';
				engine.currentScene.press(key);
				engine.guide.press(key);
			}
		}
	}
	
	public static class Guide implements Runnable, Interactive {
		private Engine engine;
		private int lastInputTime = -1;
		private boolean show_text = false;
		private PFont font;
		private String text = "《触摸星空》说明：点触油画上的星星与之交互，多次点击同一颗星星会有更多效果";
		
		private static final int WAIT_FOR_GUIDE_SHOW = 10 * 1000; // 10s
		
		public static Guide start(Engine e) {
			Guide guide = new Guide(e);
			new Thread(guide).start();
			
			return guide;
		}
		
		public Guide(Engine e) {
			engine = e;
		
			font = engine.createFont("cn_font.ttf", 32);
		}
		
		public void run() {
			while(true) {
				int now = engine.millis();
				if(now - lastInputTime > WAIT_FOR_GUIDE_SHOW)
					show_text = true;
				else
					show_text = false;
				
				// check time every one second
				try {
					Thread.sleep(500);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
		
		public void draw() {
			if(show_text) {
				engine.pushMatrix();
				engine.translate(engine.WIN_W /2, engine.WIN_H - 160, engine.WIN_D + 100);
				int greyStroke = engine.color(255, 255, 255, 130);
				engine.stroke(greyStroke);
				engine.fill(greyStroke);
				engine.textFont(font);
				engine.textAlign(engine.CENTER, engine.CENTER);
				engine.text(text, 0, 0);
				engine.popMatrix();
			}
		}
		
		public void press(char key) {
			if(key > 0) {
				updateTimestamp();
			}
		}
		
		public void click(int mouseX, int mouseY) {
			updateTimestamp();
		}
		
		public void moved() {
			updateTimestamp();
		}
		
		private void updateTimestamp() {			
			lastInputTime = engine.millis();
		}
	}
}
